import type { Matrix4 } from '../matrix/Matrix4';
import type { Quaternion } from '../rotation/Quaternion';
export declare class Vector4 {
    isVector4: boolean;
    x: number;
    y: number;
    z: number;
    w: number;
    constructor(x?: number, y?: number, z?: number, w?: number);
    set(x: number, y: number, z: number, w: number): this;
    setScalar(scalar: number): this;
    setX(x: number): this;
    setY(y: number): this;
    setZ(z: number): this;
    setW(w: number): this;
    clone(): Vector4;
    copy(v: Vector4): this;
    add(v: Vector4): this;
    addScalar(s: number): this;
    addVectors(a: Vector4, b: Vector4): this;
    addScaledVector(v: Vector4, s: number): this;
    sub(v: Vector4): this;
    subScalar(s: number): this;
    subVectors(a: Vector4, b: Vector4): this;
    multiplyScalar(scalar: number): this;
    applyMatrix4(m: Matrix4): this;
    divideScalar(scalar: number): this;
    setAxisAngleFromQuaternion(q: Quaternion): this;
    setAxisAngleFromRotationMatrix(m: Matrix4): this;
    min(v: Vector4): this;
    max(v: Vector4): this;
    clamp(min: Vector4, max: Vector4): this;
    clampScalar(minVal: number, maxVal: number): this;
    clampLength(min: number, max: number): this;
    floor(): this;
    ceil(): this;
    round(): this;
    roundToZero(): this;
    negate(): this;
    dot(v: Vector4): number;
    lengthSq(): number;
    length(): number;
    manhattanLength(): number;
    normalize(): this;
    setLength(length: number): this;
    lerp(v: Vector4, alpha: number): this;
    lerpVectors(v1: Vector4, v2: Vector4, alpha: number): this;
    equals(v: Vector4): boolean;
    fromArray(array: number[] | Float32Array, offset?: number): this;
    toArray(array: number[] | Float32Array, offset?: number): number[] | Float32Array;
}
//# sourceMappingURL=Vector4.d.ts.map